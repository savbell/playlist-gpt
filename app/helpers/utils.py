import re, requests, textwrap

def extract_playlist_id_from_link(link):
    long_url_regex = r'(?:spotify:playlist:|open\.spotify\.com\/playlist\/)([a-zA-Z0-9]+)'
    short_url_regex = r'(?:spotify\.link\/)([a-zA-Z0-9]+)'

    long_url_match = re.search(long_url_regex, link)
    short_url_match = re.search(short_url_regex, link)

    if long_url_match:
        return long_url_match.group(1)
    elif short_url_match:
        short_url = f'https://spotify.link/{short_url_match.group(1)}'
        try:
            response = requests.head(short_url, allow_redirects=True)
            long_url = response.url
            return extract_playlist_id_from_link(long_url)
        except Exception as e:
            print(f"Error resolving short URL: {e}")
            return None
    else:
        return None

def add_helper_functions(code):
    # The model kept using these functions without defining them, so I'm manually adding them since they're quite useful.
    if "get_all_playlist_tracks" in code:
        code = textwrap.dedent("""
            def get_all_playlist_tracks(playlist_id, sp):
                tracks, offset, limit = [], 0, 100
                while True:
                    batch = sp.playlist_tracks(playlist_id, offset=offset, limit=limit)
                    tracks.extend(batch['items'])
                    if len(batch['items']) < limit: break
                    offset += limit
                return tracks
            """) + "\n\n" + code
    if "get_artist_info_batched" in code:
        code = textwrap.dedent("""
            def get_artist_info_batched(artist_ids, sp, batch_size=50):
                artist_info = []
                for i in range(0, len(artist_ids := list(artist_ids)), batch_size):
                    artist_info.extend(sp.artists(artist_ids[i:i + batch_size])['artists'])
                return artist_info
            """) + "\n\n" + code
    if "get_audio_features_for_tracks" in code:
        code = textwrap.dedent("""
            def get_audio_features_for_tracks(tracks, sp):
                track_ids = [track['id'] for track in tracks]
                audio_features_dict = {}
                for i in range(0, len(track_ids), 100):
                    batch = track_ids[i:i+100]
                    audio_features = sp.audio_features(batch)
                    audio_features_dict.update({f['id']: f for f in audio_features if f})
                return audio_features_dict
            """) + "\n\n" + code
    return code


def add_dev_notes(code):
    dev_notes = textwrap.dedent("""
        '''
        This code was generated by a language model. It may not work as expected.
        
        If applicable, the following functions were manually added to the generated code:
        get_all_playlist_tracks, get_artist_info_batched, get_audio_features_for_tracks
        
        This code assumes that the following code has already been executed:
        sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="playlist-read-private,playlist-read-collaborative"))
        playlist = sp.playlist(playlist_id)
        
        Where playlist_id is a valid Spotify playlist ID.
        '''
        """)
    
    if dev_notes.strip() not in code:
        code = dev_notes + "\n\n" + code
    return code



def extract_code_and_comments(response):
    code_match = re.search(r"```(.*?)```", response, re.MULTILINE | re.DOTALL)
    if code_match:
        code = code_match.group(1).replace("python", "").strip()
        comments = response.replace(code_match.group(0), "").strip()
        code = add_helper_functions(code)
        code = add_dev_notes(code)
        code_with_helpers_and_notes = f"```\n{code}\n```"
        response = response.replace(code_match.group(0), code_with_helpers_and_notes)
    else:
        comments = ""
        code = response.replace("python", "").strip()
        code = add_helper_functions(code)
        code = add_dev_notes(code)
    return response, code, comments
