from dotenv import load_dotenv
import openai
import os
from flask import Flask, render_template, request
import spotipy
from spotipy.oauth2 import SpotifyOAuth

app = Flask(__name__)

load_dotenv()
openai.api_key = os.getenv("OPENAI_API_KEY")
openai_model = os.getenv("OPENAI_MODEL")
client_id = os.getenv("SPOTIFY_CLIENT_ID")
client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
redirect_uri = os.getenv("SPOTIFY_REDIRECT_URI")


@app.route("/", methods=("GET", "POST"))
def index():
    result = playlist_name = gpt_code = None
    if request.method == "POST":
        playlist_name = request.form["playlist_name"]
        question = request.form["question"]
        response = openai.ChatCompletion.create(
            model=openai_model,
            messages=get_messages(playlist_name, question),
        )
        gpt_code = response.choices[0]["message"]["content"]
        result = execute_gpt_code(playlist_name, gpt_code.replace("`", ""))
    return render_template("index.html", result=result, playlist_name=playlist_name, gpt_code=gpt_code)



def generate_prompt(playlist_name, question):
    return """For the playlist called {}: {}
        """.format(
                playlist_name,
                question,
            )


def get_messages(playlist_name, question):
    messages = [
        # gpt-3.5-turbo-0301 does not always pay strong attention to system messages.
        # As a workaround for now, I've added a few user messages to help the model 
        # understand not to respond to non-Spotify requests.
        {"role": "system", "content": """
            "You only respond with the Python code required to answer a question 
            about a Spotify playlist using the Spotify API. Assume we already have 
            a SimplifiedPlaylistObject called playlist. Do not include anything but 
            the code. Account for the possibility of some fields being empty. If the 
            question cannot be answered with data from the Spotify API, respond with 
            ```answer = \"Your question was unable to be answered.\"```"
            """.replace('\n', '')},
        {"role": "user", "content": "For the playlist called escalation.: Print a smiley face."},
        {"role": "assistant", "content": "```answer = \"Your question was unable to be answered.\"```"},
        {"role": "user", "content": "For the playlist called if i'm being honest,: What's 7+7?"},
        {"role": "assistant", "content": "```answer = \"Your question was unable to be answered.\"```"},
        {"role": "user", "content": "For the playlist called couch.: What is the name of the most popular track?"},
        {"role": "assistant", "content": """
            \nresults = sp.playlist_tracks(playlist['id'], fields='items(track(name,popularity))', limit=100)
            \nmost_popular_track = max(results['items'], key=lambda x: x['track']['popularity'])['track']['name']
            \nanswer = "The most popular track in the <a href='" + playlist['external_urls']['spotify'] + \
            "' target='_blank'>couch.</a> playlist is " + most_popular_track + "."
            """},
        {"role": "user", "content": generate_prompt(playlist_name, question)},
    ]
    return messages


def execute_gpt_code(playlist_name, code):
    try:
        sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id,client_secret,redirect_uri,scope="playlist-read-private"))
    except Exception as e:
        return "There was an error connecting to your Spotify account: {}".format(e)
    results = sp.search(q=playlist_name, type="playlist")
    if not results["playlists"]["items"]:
        return "No playlists with that name could be found."
    # TODO: Add logic to handle multiple playlists with the same name. Currently we just take the first result.
    
    namespace = {"playlist": results["playlists"]["items"][0], "sp": sp, "answer": "Your question was unable to be answered."}
    try:
        exec(code, namespace)
    except Exception as e:
        print(e)
        return "There was an error executing the code generated by GPT: {}".format(e)
    print("Answer: " + namespace["answer"])
    return namespace["answer"]


# # Uncomment to test generated code
# def testing(playlist_name):
#     sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id,client_secret,redirect_uri,scope="playlist-read-private"))
#     results = sp.search(q=playlist_name, type="playlist")
#     playlist = results["playlists"]["items"][0]
    
#     # Add generated code here to test
    
#     print(answer)

# testing("couch.")